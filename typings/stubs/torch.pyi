# Minimal PyTorch type stubs for essential functions
from typing import Any, Optional, Union, Tuple, Sequence

class dtype:
    def __init__(self) -> None: ...

class device:
    def __init__(self, device: Union[str, int]) -> None: ...

class Tensor:
    def __init__(self) -> None: ...
    @property
    def dtype(self) -> dtype: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    def size(self, dim: Optional[int] = None) -> Union[int, Tuple[int, ...]]: ...
    def dim(self) -> int: ...
    def view(self, *shape: int) -> "Tensor": ...
    def to(self, dtype_or_device: Union[dtype, device, str], **kwargs: Any) -> "Tensor": ...
    def contiguous(self) -> "Tensor": ...
    def reshape(self, *shape: int) -> "Tensor": ...
    def unsqueeze(self, dim: int) -> "Tensor": ...
    def squeeze(self, dim: Optional[int] = None) -> "Tensor": ...
    def float(self) -> "Tensor": ...
    def element_size(self) -> int: ...
    def repeat_interleave(self, repeats: Union[int, "Tensor"], dim: Optional[int] = None) -> "Tensor": ...
    def item(self) -> Union[int, float, bool, complex]: ...
    def __getitem__(self, key: Any) -> "Tensor": ...
    def __xor__(self, other: Union["Tensor", int, float]) -> "Tensor": ...

# Data types
uint8: dtype
int16: dtype
float16: dtype
bfloat16: dtype
float32: dtype
int32: dtype
int64: dtype
bool_dtype: dtype

# Core functions
def tensor(data: Any, dtype: Optional[dtype] = None, device: Optional[Union[device, str]] = None) -> Tensor: ...
def zeros(*size: int, dtype: Optional[dtype] = None, device: Optional[Union[device, str]] = None) -> Tensor: ...
def full(
    size: Tuple[int, ...],
    fill_value: Union[int, float],
    dtype: Optional[dtype] = None,
    device: Optional[Union[device, str]] = None,
) -> Tensor: ...
def arange(
    start: Union[int, float],
    end: Optional[Union[int, float]] = None,
    step: Union[int, float] = 1,
    dtype: Optional[dtype] = None,
    device: Optional[Union[device, str]] = None,
) -> Tensor: ...
def cat(tensors: Sequence[Tensor], dim: int = 0) -> Tensor: ...
def topk(
    input: Tensor, k: int, dim: Optional[int] = None, largest: bool = True, sorted: bool = True
) -> Tuple[Tensor, Tensor]: ...
def cos(input: Tensor) -> Tensor: ...
def sin(input: Tensor) -> Tensor: ...
def isnan(input: Tensor) -> Tensor: ...

# Distributed module
class distributed:
    @staticmethod
    def is_available() -> bool: ...
    @staticmethod
    def is_initialized() -> bool: ...
    @staticmethod
    def init_process_group(*args: Any, **kwargs: Any) -> None: ...
    @staticmethod
    def destroy_process_group() -> None: ...

def isinf(input: Tensor) -> Tensor: ...
def ldexp(input: Tensor, other: Tensor, *, out: Optional[Tensor] = None) -> Tensor: ...
